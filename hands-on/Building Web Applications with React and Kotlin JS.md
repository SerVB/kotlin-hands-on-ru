# Практика по Котлину: Создание веб приложений на React и Kotlin/JS
*От переводчика*.

Привет! Про **Kotlin** есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ (**JVM**, **JS**, **Native**), а также умеет работать с библиотеками для этих платформ, написанных на других языках. Такая поддержка "мультиплатформенности" позволяет не только писать всевозможные проекты на одном языке в единой форме, но и переиспользовать код при написании одного проекта под разные платформы.

В этой статье я перевожу [официальный туториал Kotlin Hands-On](https://play.kotlinlang.org/hands-on/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS) о создании веб сайтов на Котлине. Мы рассмотрим многие аспекты программирования на Kotlin/JS и поймем, как работать не только с чистым DOM. В основном будем говорить о [ReactJS](https://reactjs.org/), но коснемся системы сборки **Gradle**, использования зависимостей из **NPM**, обращения к **REST API**, деплоя на **Heroku**, и в итоге сделаем *приложение-видеоплеер*.

<cut/>

Надеюсь, статья не только поможет мне попрактиковаться в переводе, но и несколько удовлетворит [пусть даже непопулярные запросы](https://habr.com/ru/company/productsense/blog/526238/#comment_22257922) на материалы о Котлине на русском.

Предлагать правки в эту статью можно [на ГитХабе](https://github.com/SerVB/kotlin-hands-on-ru). Текущий перевод построен на версии оригинального туториала, актуальной на 09.04.2021.

## Содержание
1. [Введение](#step1).
1. [Настройка](#step2).
1. [Первая страница на Реакте – статичная](#step3).
1. [React – о реакциях. Наш первый компонент](#step4).
1. [Работаем совместно. Композиция компонентов](#step5).
1. [Больше компонентов!](#step6).
1. [Использование NPM пакетов](#step7).

## <a name="step1">Шаг 1. Введение</a>
На этой практике мы рассмотрим, как использовать Kotlin/JS вместе с популярным фреймворком [React](https://reactjs.org/) для создания красивых и поддерживаемых браузерных приложений. React позволяет создавать веб приложения современно и структурированно, фокусируясь на переиспользовании компонентов и на особом способе управления состоянием приложения. Он имеет большую экосистему материалов и компонентов, созданную сообществом.

Использование Котлина для написания приложений на React позволяет опираться на наши знания о парадигмах, синтаксисе и инструментах этого языка при создании фронт-энд приложений для современных браузеров. А еще использовать котлиновские библиотеки одновременно с возможностями платформы и экосистемы JavaScript.

На этой практике мы научимся создавать приложение на Kotlin/JS и React, используя Gradle плагин `org.jetbrains.kotlin.js`. Мы решим задачи, обычно возникающие при создании типичного простого React приложения.

Мы узнаем, как *предметно-ориентированные языки* (*DSL*) помогают выражать идеи кратким и единообразным способом без жертв читаемости, давая возможность написать полноценное приложение полностью на Котлине. Также мы покажем, как использовать уже сделанные сообществом компоненты и библиотеки, и как опубликовать получившееся приложение.

Предполагается, что у Вас уже есть базовое понимание Котлина, и *совсем поверхностное* знание HTML и CSS. Базовое знание идей React будет полезным для понимания примеров кода, но не обязательно.

### Что именно мы создадим
Ежегодное событие [KotlinConf](https://kotlinconf.com/) стоит посетить, если Вы хотите узнать больше о Котлине и пообщаться с сообществом. KotlinConf 2018 предлагал огромное количество информации в виде мастер-классов и лекций и был посещен 1300 участниками. Доклады публично доступны на YouTube, и поклонникам Котлина было бы полезно **видеть список** докладов, **смотреть** их на единой странице и **помечать** их как *просмотренные* – идеально для погружения в Котлин "запоем". На этой практике мы как раз создадим такое приложение – *KotlinConf Explorer*.

![Результат](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729201914738.png)

Исходный код финального приложения, как и промежуточные результаты, можно найти [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle) на GitHub. Результат каждого шага доступен в соответствующей ветке, ссылки на которые мы дополнительно дублируем в конце каждого параграфа.

Начнем с настройки среды разработки и установки инструментов, которые помогут нам в работе.

## <a name="step2">Шаг 2. Настройка</a>
### Пререквизиты
Чтобы начать, давайте убедимся, что у Вас установлена актуальная среда разработки. Вот все, что нам нужно сейчас – это IntelliJ IDEA (версии `2020.3` или новее) с плагином Котлин (`1.4.30` или новее) – скачать можно [по ссылке](https://www.jetbrains.com/idea/download/).

### Создаем проект
Для этой практики мы подготовили стартовый шаблон проекта, включающий все настройки и зависимости.

Склонируйте [этот GitHub репозиторий](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle) и откройте его с помощью IntelliJ IDEA (например с помощью **File | New | Project from Version Control...** или **Git | Clone...**).

Этот шаблон содержит простейший Kotlin/JS Gradle проект, на основе которого можно делать что-то свое. Так как Gradle конфигурация шаблона уже содержит все необходимые для практики зависимости, **Вам не придется изменять ее**.

В любом случае полезно понимать, какие артифакты используются для приложения, так что давайте посмотрим повнимательнее на шаблонные зависимости и конфигурации.

**Примечание от переводчика**: конечно, для будущих проектов можно начинать как с шаблона, так и с пустого Gradle проекта, добавляя только нужные зависимости – для этого как раз и предстоит с ними разобраться.

#### Зависимости и задачи Gradle
На практике мы будем использовать React, некоторые другие внешние зависимости, а еще котлиновские библиотеки. Чтобы не тратить время на импортирование изменений Gradle скриптов на каждом шаге, добавим все зависимости прямо сейчас.

Для начала давайте убедимся, что внутри файла `build.gradle.kts` есть блок `repositories`. Таким образом объявляются источники зависимостей.

Блок зависимостей `dependencies` содержит все нужные для практики внешние библиотеки:
```kotlin
dependencies {
    // React, React DOM + Wrappers (шаг 3)
    implementation("org.jetbrains:kotlin-react:17.0.1-pre.148-kotlin-1.4.21")
    implementation("org.jetbrains:kotlin-react-dom:17.0.1-pre.148-kotlin-1.4.21")
    implementation(npm("react", "17.0.1"))
    implementation(npm("react-dom", "17.0.1"))

    // Kotlin Styled (шаг 3)
    implementation("org.jetbrains:kotlin-styled:5.2.1-pre.148-kotlin-1.4.21")
    implementation(npm("styled-components", "~5.2.1"))

    // Video Player (шаг 7)
    implementation(npm("react-youtube-lite", "1.0.1"))

    // Share Buttons (шаг 7)
    implementation(npm("react-share", "~4.2.1"))

    // Coroutines (шаг 8)
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3")
}
```

Если отредактировать файл, IDEA автоматически предложит импортировать изменения Gradle скриптов. Импорт также можно инициировать в любой момент, нажав на кнопку **🔁 Reimport All Gradle Projects** в тул-окне Gradle (сбоку справа).

#### HTML страница
Так как мы не можем вызывать JavaScript сам по себе, мы должны написать связанную с нашим JS файлом HTML страницу, и именно ее открывать в браузере. В проекте уже есть файл `src/main/resources/index.html` со следующим содержимым:
```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hello, Kotlin/JS!</title>
</head>
<body>
    <div id="root"></div>
    <script src="confexplorer.js"></script>
</body>
</html>
```

Благодаря Kotlin/JS Gradle плагину, весь наш код и зависимости будут объединены ("забандлены") в единый JavaScript артефакт, носящий с проектом одно имя. Соответственно мы добавили в HTML файл вызов скрипта `confexplorer.js` (заметьте, что если бы проект был назван `followingAlong`, имя скрипта было бы `followingAlong.js`).

Выполняя обыденную [конвенцию JavaScript](https://faqs.skillcrush.com/article/176-where-should-js-script-tags-be-linked-in-html-documents), мы сначала позволяем загрузить контент нашей страницы (включая элемент `#root`) и только в конце загружаем скрипт. Таким образом, страница будет загружена к моменту выполнения нашего скрипта, и мы сможем сразу же к ней обращаться.

**Примечание от переводчика**: если у Вас уже есть опыт с HTML, возможно, Вы привыкли использовать свойство `onLoad` у элемента `body` для решения этой же проблемы. Однако при использовании Kotlin/JS намного проще именно просто объявлять скрипт в конце `body`.

Перед написанием "Hello, World" с настоящей разметкой, начнем с простейшего визуального примера – страницы, залитой сплошным цветом. Этот пример поможет понять, то что наш код действительно доходит до браузера и выполняется без ошибок. Для кода у нас есть файл `src/main/kotlin/Main.kt` с таким содержимым:
```kotlin
import kotlinx.browser.document

fun main() {
    document.bgColor = "red"
}
```

Теперь нам нужно скомпилировать и запустить наш код.

### Запуск сервера для разработки
`kotlin.js` Gradle плагин из коробки поддерживает **webpack-dev-server**, что позволяет нам хостить приложение прямо с помощью IDE и не настраивать подобный веб сервер отдельно.

Мы можем стартовать сервер, вызвав задачу `run` или `browserDevelopmentRun` из тул-окна Gradle, она может быть либо в группе `other` (как на скриншоте), либо в `kotlin browser`:
![Задача для запуска сервера](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/browserDevelopmentRun.png)

Если хочется запускать не из IDE, а из терминала, то можно выполнить `./gradlew run` (*в Windows* Gradle команды выглядят немного по-другому: `.\gradlew.bat run`).

Наш проект скомпилируется и забандлится, и через несколько секунд должно открыться окно браузера с пустой красной страницей, означающей, что наш код заработал успешно:
![Красная страница](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/redPage.png)

#### Включение горячей перезагрузки (hot reload) a.k.a. непрерывного режима
Вместо того чтобы вручную вызывать компиляцию проекта и обновление страницы в браузере для тестирования изменений в коде, мы можем использовать *режим непрерывной компиляции* – Kotlin/JS поддерживает ее. Для этого нам потребуется немного модифицировать вызов `run` задачи Gradle.

Необходимо также убедиться, что запущенный ранее веб сервер остановлен (нажмите в IDE на красный квадрат – **Stop**, а в терминале – `Ctrl+C`).

Если Вы запускаете задачу с помощью IDEA, нужно добавить флаг в конфигурацию запуска. Эту конфигурацию IDEA создала, когда мы впервые запустили Gradle задачу, а теперь нам нужно ее отредактировать:
![Открытие редактирования](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/editConfigurations.png)

В открывшемся окне **Run/Debug Configurations** надо добавить флаг `--continuous` в аргументы конфигурации запуска:
![Добавление аргумента](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/continuous.png)

После применения изменений, мы можем использовать зеленую кнопку **Run** (▶) для запуска сервера.

Если Вы запускаете из терминала, это можно сделать примерно так: `./gradlew run --continuous`.

Для тестирования только что активированной функции, предлагаем изменить цвет страницы, когда Gradle задача выполняется. Например, можно изменить на синий:
```kotlin
document.bgColor = "blue"
```

Если сохранить файл, через пару секунд проект должен автоматически перекомпилироваться, а страница браузера – перезагрузиться и окраситься в новый цвет.

Во время разработки можно оставлять сервер запущенным. Он будет следить за изменениями в коде и автоматически компилировать код и перезагружать страницу. Если хотите, можете поиграться с кодом на этой начальной стадии.

#### Примечание от переводчика насчет непрерывной компиляции
Если честно, я пробовал этот режим, и он мне показался неудобным. Во-первых, перезагрузка страницы иногда бывает нежелательна, особенно если там были какие-то несохраненные данные. Во-вторых, я не всегда понимаю, успели ли уже перекомпилироваться код и перезагрузиться страница. В-третьих, этот режим почему-то не всегда видит изменения, и доходит до того, что приходится перезапускать Gradle задачу, то есть сама суть режима нарушается – все еще приходится делать что-то руками.

В итоге, я уже года два, с момента начала моего использования Kotlin/JS, вручную запускаю компиляцию кода и перезагрузку страницы. Более того, я вообще не использую веб сервер при разработке: я просто открываю в браузере локальный HTML файл. Для компиляции я использую задачу `browserDevelopmentWebpack`, после этого построенные файлы становятся доступны в папке `build/distributions` или в `build/developmentExecutable`. Оттуда я переношу в браузер файл `index.html`, и все работает довольно безотказно и предельно логично.

### На старт, внимание...
Мы настроили пустой Kotlin/JS проект, который может развиться во все что угодно. Время начинать верстать!

> Состояние проекта после выполнения этого шага доступно в ветке `master` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/master).

## <a name="step3">Шаг 3. Первая страница на Реакте – статичная</a>
В мире программирования принято начинать обучение с *Hello, World*. Так давайте изменим нашу одноцветную страницу в соответствии с традициями.

Поменяйте код в файле `src/main/kotlin/Main.kt` на примерно следующий:
```kotlin
import react.dom.*
import kotlinx.browser.document

fun main() {
    render(document.getElementById("root")) {
        h1 {
            +"Hello, React+Kotlin/JS!"
        }
    }
}
```

После сборки изменившегося проекта в браузере можно увидеть магию:
![hello-world](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729142055566.png)

Ура, Вы только что написали свой первый вебсайт на чистом Котлине с Реактом! Давайте попробуем понять, как работает этот код. Функция `render` говорит библиотеке [kotlin-react-dom](https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-dom) отрендерить наш *компонент* (поговорим о компонентах чуть позже) внутрь элемента на странице. Если помните, в `src/main/resources/index.html` есть элемент с ID `root`, как раз туда мы и рендерим. Содержимое рендеринга сейчас довольно простое – единственный заголовок первого уровня. Для объявления содержимого, то есть HTML элементов, используется типобезопасный DSL.

### Типобезопасный HTML
Библиотека [kotlin-react](https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-react/README.md) использует котлиновскую возможность написания DSL, таким образом заменяя синтаксис разметки HTML на нечто более легкочитаемое. Возможно, такой DSL Вам покажется и легче в написании.

Код на Котлине дает нам все преимущества статически типизированного языка, от *проверки типов* до *автодополнения*. Скорее всего, из-за этого Вы проведете *меньше времени в отладке*, охотясь за опечатками в именах аттрибутов, и у Вас появится *больше времени на создание* отточенного приложения!

**О знаке `+`**:

Единственная довольно неочевидная на первый взгляд вещь в котлиновском листинге выше – знак `+` перед строковым литералом. Поясним! `h1` – это функция, принимающая лямбду как параметр. Когда мы пишем `+`, мы на самом деле вызываем [перегруженный оператор](https://kotlinlang.org/docs/reference/operator-overloading.html) `unaryPlus`, которая добавляет строку в окружающий HTML элемент.

Проще говоря, операцию `+` можно понимать как инструкцию "добавь мою строчку текста внутрь этого элемента".

#### Переписываем классический HTML
Когда у нас есть мысли о том, как будет выглядеть наш сайт, мы можем сразу перевести наш (мысленный) набросок в котлиновское объявление HTML. Если Вы уже привыкли писать обычный HTML, у Вас не должно возникнуть проблем и с котлиновским. Сейчас мы хотим создать разметку, которую можно записать примерно так на чистом HTML:
```html
<h1>KotlinConf Explorer</h1>
<div>
    <h3>Videos to watch</h3>
    <p>John Doe: Building and breaking things</p>
    <p>Jane Smith: The development process</p>
    <p>Matt Miller: The Web 7.0</p>

    <h3>Videos watched</h3>
    <p>Tom Jerry: Mouseless development</p>
</div>
<div>
    <h3>John Doe: Building and breaking things</h3>
    <img src="https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder">
</div>
```

Давайте переведем этот код в Kotlin DSL. Конверсия довольно прямолинейна. Если хотите поупражняться, можете попробовать переписать самостоятельно, **не подглядывая** в листинг ниже:
```kotlin
h1 {
    +"KotlinConf Explorer"
}
div {
    h3 {
        +"Videos to watch"
    }
    p {
        +"John Doe: Building and breaking things"
    }
    p {
        +"Jane Smith: The development process"
    }
    p {
        +"Matt Miller: The Web 7.0"
    }

    h3 {
        +"Videos watched"
    }
    p {
        +"Tom Jerry: Mouseless development"
    }
}
div {
    h3 {
        +"John Doe: Building and breaking things"
    }
    img {
       attrs {
           src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
       }
    }
}
```

Перепишите или скопируйте этот листинг внутрь вызова `render`. Если IntelliJ IDEA ругается на отсутствующие импорты, просто вызовите соответствующие быстрые исправления (quick-fixes) с помощью `Alt+Enter`. Когда обновленный файл будет скомпилирован и страница в браузере перезагружена, Вас будет приветствовать следующий экран:
![kotlinconf-placeholder](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729143514676.png)

### Использование котлиновских языковых конструкций в разметке
Написание HTML на DSL на самом деле имеет намного больше преимуществ, по сравнению с чистым HTML. Основное отличие – это то что мы можем жонглировать контентом страницы, используя **уже знакомые нам конструкции языка**. Условные переходы, циклы, коллекции, подстановка внутри строк – все это будет работать в HTML DSL так же, как и обычно в Котлине.

Давайте теперь вместо захардкоживания списка видео объявим переменную-список и будем ее использовать в разметке. Создадим класс `KotlinVideo`, чтобы хранить свойства видео (класс можно создать либо в `Main.kt`, либо в другом файле – как хотите), а также `external` интерфейс – о нем поговорим позже, когда будем получать данные из внешнего API:
```kotlin
external interface Video {
    val id: Int
    val title: String
    val speaker: String
    val videoUrl: String
}

data class KotlinVideo(
    override val id: Int,
    override val title: String,
    override val speaker: String,
    override val videoUrl: String
) : Video
```

Потом объявим два списка: для непросмотренных и просмотренных видео. Пока что можно сделать это в файле `Main.kt` на верхнем уровне:
```kotlin
val unwatchedVideos = listOf(
    KotlinVideo(1, "Building and breaking things", "John Doe", "https://youtu.be/PsaFVLr8t4E"),
    KotlinVideo(2, "The development process", "Jane Smith", "https://youtu.be/PsaFVLr8t4E"),
    KotlinVideo(3, "The Web 7.0", "Matt Miller", "https://youtu.be/PsaFVLr8t4E")
)

val watchedVideos = listOf(
    KotlinVideo(4, "Mouseless development", "Tom Jerry", "https://youtu.be/PsaFVLr8t4E")
)
```

Чтобы использовать эти значения в HTML, нам не нужно знать ничего, кроме базового синтаксиса Котлина! Мы можем написать код для прохода по коллекции и добавлять HTML элемент для каждого элемента коллекции. То есть вместо трех тегов `p` для непросмотренных видео, мы можем написать примерно такое:
```kotlin
for(video in unwatchedVideos) {
    p {
        +"${video.speaker}: ${video.title}"
    }
}
```

Аналогично можно изменить разметку чуть ниже для использования списка `watchedVideos`. После перекомпиляции проекта и обновления страницы мы убедимся, что страница эквивалентна предыдущему варианту. Если хотите удостовериться, что циклы на самом деле работают, попробуйте поэкспериментировать и, например, добавить новые элементы в списки.

### Типобезопасный CSS
Можно сказать, мы уже продвинулись в проекте, но не время делать паузу: к сожалению, наше приложение до сих пор выглядит *несколько безвкусно* и *не сильно привлекательно*. Для исправления ситуации мы могли бы подключить какой-нибудь `.css` файл в наш файл `index.html`, но давайте лучше воспользуемся случаем, чтобы поиграться с Kotlin DSL опять – на этот раз с CSS.

Библиотека [kotlin-styled](https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-styled) предоставляет чудесные типобезопасные обертки для [styled-components](https://www.styled-components.com/) и позволяет нам быстро и безопасно объявлять стили как [глобально](https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-styled/README.md#global-styles), так индивидуально для конкретных компонентов. Эти обертки очень похожи на концепт [CSS-in-JS](https://reactjs.org/docs/faq-styling.html#what-is-css-in-js). Описывая стили *на Котлине*, мы опять же получаем возможность использовать краткие, понятные и единообразные языковые конструкции.

Нам не нужно делать дополнительных шагов для использования этого CSS DSL, так как мы уже добавили все зависимости в конфигурацию Gradle. Вот соответствующий блок:
```kotlin
dependencies {
    //...
    // Kotlin Styled (шаг 3)
    implementation("org.jetbrains:kotlin-styled:5.2.1-pre.148-kotlin-1.4.21")
    implementation(npm("styled-components", "~5.2.1"))
    //...
}
```

Теперь вместо блоков вроде `div` или `h3` мы можем использовать их аналоги с префиксом `styled`, например, `styledDiv` или `styledH3`. Внутри их тел мы можем настраивать стили с помощью блока `css`. Например, для сдвига видеоплеера в правый верхний угол страницы, мы можем изменить наш код примерно так:
```kotlin
styledDiv {
    css {
        position = Position.absolute
        top = 10.px
        right = 10.px
    }
    h3 {
        +"John Doe: Building and breaking things"
    }
    img {
        attrs {
            src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
        }
    }
}
```

Скорее всего, IDEA начнет жаловаться на непонятные ссылки. Мы можем избавиться от этих ошибок, добавив импорты сверху в файле:
```kotlin
import kotlinx.css.*
import styled.*
```

Или можно воспользоваться быстрыми исправлениями с помощью `Alt+Enter` для добавления импортов автоматически.

Мы привели довольно минималистичный пример. Не стесняйтесь поэкспериментировать – поменять стиль приложения, как душе угодно. Можете даже поиграться с CCS Grids, чтобы сделать интерфейс отзывчивым (но эта тема уже слишком сложна для этого туториала). Попробуйте сделать шрифт (свойство `fontFamily`) заголовка без засечек (значение `sans-serif`), или, например, сделать красивые цвета (свойство `color`).

> Состояние проекта после выполнения этого шага доступно в ветке `step-02-first-static-page` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-02-first-static-page).

## <a name="step4">Шаг 4. React – о реакциях. Наш первый компонент</a>
### Основная идея
Базовые строительные блоки в Реакте называются **компонентами**. Комбинируя компоненты, часть из которых в свою может быть комбинацией других более маленьких, мы создаем приложение. Делая компоненты переиспользуемыми и обобщенными, мы можем помещать их в несколько мест в приложении, *не дублируя* код и/или логику.

На самом деле, *корневой элемент* нашего рендеринга тоже можно представить как компонент. Если мы отметим его рамкой, то это будет выглядеть примерно так:
![root-component](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729153736304.png)

А если посмотреть на структуру приложения, то можно найти следующие компоненты, каждый из которых имеет свою ответственность:
![split-components](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729153826920.png)

### Корневой компонент
Давайте разобьем приложение на компоненты в соответствии со структурой. Начнем с явного объявления главного компонента `App`, который будет являться корневым. Для этого создадим файл `App.kt` по пути `src/main/kotlin` в проекте. Внутри файла опишем класс `App`, наследующий `RComponent` (сокращение от **R**eact **Component**). Обобщения пока что можно оставить стандартными (`RProps` и `RState`), а потом разберемся и с ними:
```kotlin
import react.*

@JsExport
class App : RComponent<RProps, RState>() {

    override fun RBuilder.render() {
        // Помещаем сюда типобезопасный HTML!
    }
}
```

Переместите весь наш типобезопасный HTML внутрь новой функции `render`. Таким образом мы поместили весь код приложения в соответствующе названый явный компонент. Теперь функция `main` должна как-то ссылаться на `App`. Это делается очень просто: достаточно сказать Реакту рендерить компонент `App` как ребенка корневого элемента, используя функцию `child`:
```kotlin
fun main() {
    render(document.getElementById("root")) {
        child(App::class) {}
    }
}
```

В ходе туториала мы будем создавать и использовать компоненты, так что скорее всего Вы станете понимать их лучше. Но если есть желание нырнуть в Реакт поглубже, рекомендуем изучить [официальную документацию и гайды](https://reactjs.org/docs/hello-world.html#how-to-read-this-guide).

### Компонент для списка
Какие части нашего приложения дублируются? Конечно же, *списки видео* – и это сразу же заметно. Так как и список непросмотренного, и список просмотренного имеют одинаковую функциональность, есть смысл создать единый компонент и переиспользовать его.

Сделаем это в новом файле `VideoList.kt`. Подобно классу `App`, создадим класс `VideoList`, наследующий `RComponent` и содержащий HTML DSL со списком `unwatchedVideos`:
```kotlin
import react.*
import react.dom.*

@JsExport
class VideoList : RComponent<RProps, RState>() {

    override fun RBuilder.render() {
        for (video in unwatchedVideos) {
            p {
                +"${video.speaker}: ${video.title}"
            }
        }
    }
}
```

Теперь часть со списками внутри `App` можно сделать примерно такой:
```kotlin
div {
    h3 {
        +"Videos to watch"
    }
    child(VideoList::class) {}

    h3 {
        +"Videos watched"
    }
    child(VideoList::class) {}
}
```

Однако здесь можно заметить проблему: `App` не управляет содержимым списка. Сейчас содержимое захардкожено и будет всегда одинаковое. Выходит, нам нужен механизм передачи списка *внутрь компонента*.

### Добавляем аттрибуты
Теперь мы понимаем, что при переиспользовании компонента-списка мы бы хотели заполнять его разным содержимым. Другими словами, вместо хранения списка элементов статически, мы хотели бы задавать его внешне и передавать компоненту как аттрибуты. Реакт называет такие аттрибуты как `props`. Когда аттрибуты задаются, Реакт берет на себя задачу по их передаче в компонент и по рендерингу компонента.

В нашем случае мы хотим добавить аттрибут, содержащий список докладов. Давайте переработаем наш код. Создайте следующий интерфейс в файл `VideoList.kt`:
```kotlin
external interface VideoListProps : RProps {
    var videos: List<Video>
}
```

Теперь изменим объявление класса `VideoList`, чтобы он использовал этот аттрибут:
```kotlin
@JsExport
class VideoList : RComponent<VideoListProps, RState>() {

    override fun RBuilder.render() {
        for (video in props.videos) {
            p {
                key = video.id.toString()
                +"${video.speaker}: ${video.title}"
            }
        }
    }
}
```

Так как содержимое компонента теперь потенциально динамично (то есть переданные в рантайме аттрибуты могут меняться, и мы так будем делать в следующих шагах), следует добавлять аттрибут `key` в каждый элемент списка. Он помогает Реакту понять, какие части списка нужно обновить, а какие можно оставить без изменений – хорошая и почти бесплатная оптимизация! Больше информации насчет списков и ключей можно найти например в [официальном гайде Реакта](https://reactjs.org/docs/lists-and-keys.html).

Наконец, на месте использования `VideoList` (внутри `App`) нам остается передать правильные аттрибуты. Подставьте `unwatchedVideos` и `watchedVideos` примерно так:
```kotlin
child(VideoList::class) {
    attrs.videos = unwatchedVideos
}
```

Проверьте в браузере, что списки рендерятся, как задумано. Таким образом, мы инкапсулировали обязанность рендеринга списка видео внутри соответствующего компонента. Это должно укорачивать исходный код и делать его более легкочитаемым и понимаемым как для нас, так и для коллег.

### Уменьшаем громоздкость вызова
Если Вам тоже не очень нравится предыдущая конструкция, мы можем улучшить ее, используя крутую котлиновскую фичу под названием [функция с получателем](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver). Выделим функцию, которая делает доступ к компонентам легче: она выполняет то же самое, что и предыдущая конструкция, но изменяет синтаксис использования:
```kotlin
fun RBuilder.videoList(handler: VideoListProps.() -> Unit): ReactElement {
    return child(VideoList::class) {
        attrs.handler()
    }
}
```

Расскажем, что происходит в этом коде: мы определяем функцию `videoList` как [расширение](https://kotlinlang.org/docs/reference/extensions.html) для типа `RBuilder`. Функция принимает единственный параметр `handler`, функцию-расширение для `VideoListProps`, возвращающую `Unit`. Функция оборачивает вызов `child` (который мы делали изначально для вставки `VideoList`), и вызывает `handler` на объекте `attrs`.

Основной смысл такой функции – облегчение синтаксиса использования нашего компонента: теперь мы можем писать просто
```kotlin
videoList {
    videos = unwatchedVideos
}
```

В общем, мы убираем из вызова не сильно информативные слова типа `child`, `class` и `attrs`, оставляя только специфичные для конкретного компонента символы. Аналогичные функции можно писать для всех компонентов, которые Вы описываете. Запомните этот трюк! При желании потренироваться уже сейчас можете попробовать это проделать для класса `App`.

### Добавляем интерактивность
Основная цель нашего компонента-списка – задавать видео для показа в видеоплеере. Чтобы это сделать, нужно позволить пользователю взаимодействовать с элементами списка. Начнем с простого: будем показывать выбранное пользователем видео в диалоге `alert`.

Для этого модифицируем код внутри функции `VideoList.render`. Сделаем так, чтобы при клике на элемент `p` соответствующее сообщение показывалось бы в диалоге:
```kotlin
p {
    key = video.id.toString()
    attrs {
        onClickFunction = {
            window.alert("Clicked $video!")
        }
    }
    +"${video.speaker}: ${video.title}"
}
```

Если IntelliJ IDEA просит добавить импорты, это можно сделать по нажатию `Alt+Enter`. Или можно добавить импорты вручную:
```kotlin
import kotlinx.html.js.onClickFunction
import kotlinx.browser.window
```

Теперь при клике на элементе списка в браузере мы увидим всплывающее сообщение о выбранном элементе:
![alert](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729161705147.png)

> Оформлять значение `onClickFunction` как лямбду довольно коротко, и это удобно как минимум для прототипирования. Однако на данный момент эквивалентность ссылок на функции в Kotlin/JS работает [не очень очевидно](https://youtrack.jetbrains.com/issue/KT-15101). Поэтому передача лямбды на самом деле не сильно эффективна в плане производительности. Если Вам нужна максимальная эффективность, необходимо сохранять ссылки на функции в неменяющихся во время выполнения переменных и передавать в качестве значений для `onClickFunction` и других подобных свойств эти переменные.

### Добавляем состояние
Не устали?

Давайте сделаем настоящий селектор видео вместо вывода всплывающего сообщения. Будем подсвечивать выбранное видео треугольником (▶). Реакт нам поможет – он позволяет ввести некоторое *состояние* для компонента. Это будет очень похоже на добавление аттрибутов – надо объявить интерфейс:
```kotlin
external interface VideoListState : RState {
    var selectedVideo: Video?
}
```

Дальше надо сделать следующее:
* Подредактировать объявление класса `VideoList`, чтобы в качестве типа состояния он использовал `VideoListState` – нужно унаследовать компонент от `RComponent<..., VideoListState>`.
* При рендеринге списка, для выбранного видео мы должны выводить треугольник в качестве префикса.
* Внутри `onClickFunction` надо записывать в состояние `selectedVideo` то видео, которое соответствует кликнутому элементу. Чтобы компонент перерисовывался при изменении состояния, код для изменения нужно обернуть лямбду и передать ее в функцию `setState`. 

Когда проделаем это, мы получим такой класс:
```kotlin
@JsExport
class VideoList : RComponent<VideoListProps, VideoListState>() {

    override fun RBuilder.render() {
        for (video in props.videos) {
            p {
                key = video.id.toString()
                attrs {
                    onClickFunction = {
                        setState {
                            selectedVideo = video
                        }
                    }
                }
                if (video == state.selectedVideo) {
                    +"▶ "
                }
                +"${video.speaker}: ${video.title}"
            }
        }
    }
}
```

> **Состояние стоит модифицировать только внутри `setState`**. Так Реакт сможет обнаружить изменения и перерисовать нужные части UI быстро и эффективно.

На этом шаге у нас все, но более подробно о состоянии можно почитать в официальном [React FAQ](https://reactjs.org/docs/faq-state.html).

> Состояние проекта после выполнения этого шага доступно в ветке `step-03-first-component` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-03-first-component).

## <a name="step5">Шаг 5. Работаем совместно. Композиция компонентов</a>
Сделанные нами на предыдущем шаге пара списков сами по себе вполне работают. Однако, если мы кликнем по одному видео в каждом из списков, мы сможем выбрать *два видео* одновременно. Это неправильно, ведь у нас только один плеер :)
![pair](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729172131420.png)

По-хорошему, у обоих списков должно быть единое состояние – выбранное видео, которое будет одним на все приложение. Но одинаковое состояние не может (и не должно) храниться в разных компонентах. Принято выносить состояние наверх (как еще говорят, "поднимать" состояние).

### Вынос состояния наверх
Чтобы не прибивать гвоздями разные компоненты друг к другу и не создавать спагетти-код, можно воспользоваться иерархией компонентов Реакта: передавать аттрибуты из родительского компонента. Если компонент хочет изменять состояние соседнего компонента, это следует делать через общего родителя. Значит, состояние должно быть не в соседнем компоненте, а именно в родителе. Миграция состояния из компонента к родителю называется **выносом** состояния. Давайте выносить его в нашем случае! Для этого нам нужно добавить состояние для нашего родительского компонента, `App`. Будем действовать примерно так же, как и с состоянием для `VideoList`.

Объявим интерфейс:
```kotlin
external interface AppState : RState {
    var currentVideo: Video?
}
```

И сошлемся на него в классе `App`:
```kotlin
@JsExport
class App : RComponent<RProps, AppState>()
```

Удалим `VideoListState`, так как мы теперь будем хранить эту информацию выше. Получается, мы вообще убрали состояние у списка, так что вернем его состояние к стандартному в описании класса:
```kotlin
@JsExport
class VideoList : RComponent<VideoListProps, RState>()
```

Теперь передадим вниз состояние выбранного видео из `App` в `VideoList` как аттрибут. Добавим свойство в интерфейс `VideoListProps`, которое будет содержать выбранное видео:
```kotlin
external interface VideoListProps : RProps {
    var videos: List<Video>
    var selectedVideo: Video?
}
```

Поправим условие для показа треугольника выбранного видео, чтобы оно использовало аттрибуты вместо состояния:
```kotlin
if (video == props.selectedVideo) {
    +"▶ "
}
```

Но есть еще одна проблема, которую создал наш рефакторинг: у компонента нет доступа к родительскому состоянию, так что вызов `setState` внутри `onClickFunction` не сможет сделать ничего полезного. Чтобы обороть это и в итоге опять получить работающее приложение, давайте поднимем кое-что еще.

### Передача обработчиков
К сожалению, Реакт не позволяет изменять состояние родительского компонента напрямую, как бы мы этого не хотели. Но мы можем поступить по-другому: переместить логику обработки действия пользователя в аттрибут и передавать его из родителя. Помните, что в Котлине у переменных может быть [функциональный тип](https://kotlinlang.org/docs/reference/lambdas.html#function-types)? Добавим еще в одно свойство в интерфейс – функцию, принимающую `Video` и возвращающую `Unit`:
```kotlin
external interface VideoListProps : RProps {
    var videos: List<Video>
    var selectedVideo: Video?
    var onSelectVideo: (Video) -> Unit
}
```

И соответственно поменяем `onClickFunction` на вызов этой функции из аттрибутов:
```kotlin
onClickFunction = {
    props.onSelectVideo(video)
}
```

Теперь мы сможем передавать выбранное видео как аттрибут и вынести логику *выбора* видео в родительский компонент, где и будем менять состояние. Иными словами, мы хотим поднять логику обработки кликов в родителя. Обновим оба места использования `videoList`:
```kotlin
videoList {
    videos = unwatchedVideos
    selectedVideo = state.currentVideo
    onSelectVideo = { video ->
        setState {
            currentVideo = video
        }
    }
}
```

Второе место отличается присваиванием `watchedVideos`.

При необходимости перекомпилируйте проект и убедитесь, что теперь все работает логично: при выборе видео в двух списках, треугольник перепрыгивает между списками, а не дублируется. Возможно, Вы даже удивитесь, как все оказалось просто.

> Состояние проекта после выполнения этого шага доступно в ветке `step-04-composing-components` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-04-composing-components).

## <a name="step6">Шаг 6. Больше компонентов!</a>

Мы сделали один компонент отдельным и самодостаточным, а также оставили у него возможность взаимодействовать с приложением. Давайте проделаем то же самое для остальных частей приложения.

### Выносим компонент видеоплеера

Еще одна часть приложения, которую стоит вынести как обособленную единицу – это видеоплеер (его мы все еще заменяем заглушечной картинкой). Давайте подумаем, какие аттрибуты понадобятся для видеоплеера: это автор видео, название и ссылка. На самом деле, все эти свойства уже имеет объект типа `Video`, так что будем передавать его как аттрибут. Создадим новый компонент `VideoPlayer` в файле `VideoPlayer.kt`:
```kotlin
import kotlinx.css.*
import kotlinx.html.js.onClickFunction
import react.*
import react.dom.*
import styled.*

external interface VideoPlayerProps : RProps {
    var video: Video
}

@JsExport
class VideoPlayer : RComponent<VideoPlayerProps, RState>() {
    override fun RBuilder.render() {
        styledDiv {
            css {
                position = Position.absolute
                top = 10.px
                right = 10.px
            }
            h3 {
                +"${props.video.speaker}: ${props.video.title}"
            }
            img {
                attrs {
                    src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
                }
            }
        }
    }
}

fun RBuilder.videoPlayer(handler: VideoPlayerProps.() -> Unit): ReactElement {
    return child(VideoPlayer::class) {
        this.attrs(handler)
    }
}
```

Теперь заменим предыдущий `styledDiv` с видеоплеером (в файле `App.kt`) на только что вынесенный компонент. Будем его отрисовывать, только если выбрано какое-то видео – воспользуемся комбинацией оператора безопасного вызова и функции `let`, тогда переданный в `let` блок кода будет выполняться, если `currentVideo` не равно `null`:
```kotlin
state.currentVideo?.let { currentVideo ->
    videoPlayer {
        video = currentVideo
    }
}
```

### Добавляем и присоединяем кнопку
Пока что в приложении нет способа двигать видео между списками непросмотренных и просмотренных. Для решения этой задачи добавим кнопку в `VideoPlayer`.

Мы хотим двигать элементы между разными списками, а они находятся за пределами нашего компонента `VideoPlayer`. Вспомним, что в подобных случаях нам надо выносить в общего родителя логику обработки нажатия кнопки.

Попробуем сделать кнопку-переключатель. При нажатии ее состояние, например, текст, будет изменяться в зависимости от того, просмотрено видео или нет. Для этого будем передавать еще и состояние кнопки.

Добавим еще свойств в интерфейс `VideoPlayerProps`:
```kotlin
external interface VideoPlayerProps : RProps {
    var video: Video
    var onWatchedButtonPressed: (Video) -> Unit
    var unwatchedVideo: Boolean
}
```

Мы уже создали несколько компонентов, так что реализация кнопки не должна быть сложной задачей. Попробуем использовать аттрибуты для изменения CSS свойств: будем раскрашивать кнопку динамически на основе состояния видео. Добавим следующий HTML DSL в метод `render` видеоплеера, между тегами `h3` и `img`:
```kotlin
styledButton {
    css {
        display = Display.block
        backgroundColor = if (props.unwatchedVideo) Color.lightGreen else Color.red
    }
    attrs {
        onClickFunction = {
            props.onWatchedButtonPressed(props.video)
        }
    }
    if (props.unwatchedVideo) {
        +"Mark as watched"
    } else {
        +"Mark as unwatched"
    }
}
```

### Перемещаем списки видео в состояние приложения
Перед тем как изменить вызов `VideoPlayer`, подумаем о логике его работы.

При клике на кнопку, видео должно быть либо перенесено из списка `unwatched` в `watched`, либо наоборот.

То есть списки могут изменяться. Давайте тогда перенесем их в состояние приложения! Опять добавим дополнительные свойства в интерфейс:
```kotlin
external interface AppState : RState {
    var currentVideo: Video?
    var unwatchedVideos: List<Video>
    var watchedVideos: List<Video>
}
```

Начальные значения состояния можно задать в методе `init`. Сделаем это, переопределив метод в классе `App`:
```kotlin
override fun AppState.init() {
    unwatchedVideos = listOf(
        KotlinVideo(1, "Building and breaking things", "John Doe", "https://youtu.be/PsaFVLr8t4E"),
        KotlinVideo(2, "The development process", "Jane Smith", "https://youtu.be/PsaFVLr8t4E"),
        KotlinVideo(3, "The Web 7.0", "Matt Miller", "https://youtu.be/PsaFVLr8t4E")
    )
    watchedVideos = listOf(
        KotlinVideo(4, "Mouseless development", "Tom Jerry", "https://youtu.be/PsaFVLr8t4E")
    )
}
```

Теперь можно удалить `unwatchedVideos` и `watchedVideos` из файла `Main.kt`, а в файле `Main.kt` заменить все вызовы (`un`)`watchedVideos`, которые наверняка IDE уже успела подсветить как ошибочные, на `state.`(`un`)`watchedVideos`.

Наконец, подкорректируем вызов видеоплеера. Он будет выглядеть вот так:
```kotlin
videoPlayer {
    video = currentVideo
    unwatchedVideo = currentVideo in state.unwatchedVideos
    onWatchedButtonPressed = {
        if (video in state.unwatchedVideos) {
            setState {
                unwatchedVideos -= video
                watchedVideos += video
            }
        } else {
            setState {
                watchedVideos -= video
                unwatchedVideos += video
            }
        }
    }
}
```

Вернитесь в браузер, выберите видео, нажмите на кнопку пару раз и убедитесь, что видео перемещается между двумя списками.

Таким образом, мы реализовали основную логику нашего приложения. Будет здорово, если Вы поиграетесь со стилями кнопки, и выберете тот, который Вам больше всего по душе. Можете даже попробовать вынести кнопку в отдельный переиспользуемый компонент!

Время откинуться на спинку сиденья и переложить тяжелую работу на других. В следующем шаге поговорим об использовании готовых и общедоступных Реакт компонентов из Котлина.

> Состояние проекта после выполнения этого шага доступно в ветке `step-05-more-components` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-05-more-components).

## <a name="step7">Шаг 7. Использование NPM пакетов</a>
Хотя мы уже неплохо продвинулись, в приложении все еще отсутствуют жизненно важные части. Вместо написания всего с нуля, попробуем использовать богатую экосистему, построенную вокруг Реакта. В ней есть тонна уже готовых компонентов, так что давайте действительно не переизобретать велосипед, а использовать их.

Первая и самая очевидная недостающая функциональность – это видеоплеер.

### Добавляем компонент видеоплеера
Нужно заменить нашу заглушку на компонент, способный показывать видео с Ютуба. Воспользуемся компонентом из библиотеки `react-youtube-lite`. Его документацию и API можно найти в [README](https://www.npmjs.com/package/react-youtube-lite).

Вспомним самое начало практики. Там мы видели зависимость на `react-youtube-lite`, объявленную в файле Gradle. Вот то место:
```kotlin
dependencies {
    // ...
    // Video Player (шаг 7)
    implementation(npm("react-youtube-lite", "1.0.1"))
    // ...
}
```

Вы понимаете правильно – NPM зависимости могут быть добавлены в Gradle проект с помощью функции `npm`. `yarn`, который вызывается Kotlin/JS Gradle плагином под капотом, позаботится о загрузке, установке и обновлении этих зависимостей.

Когда мы хотим использовать NPM модули из Котлина, необходимо рассказать компилятору о сигнатурах: что можно вызывать, присваивать или читать. После этого все будет статически типизировано, и тулинг сможет помогать нам писать обычный код на Котлине. Объявлять декларации для каждого внешнего модуля надо в отдельном файле. Создадим файл `ReactYouTube.kt` со следующим содержимым:
```kotlin
@file:JsModule("react-youtube-lite")
@file:JsNonModule

import react.*

@JsName("ReactYouTubeLite")
external val reactPlayer: RClass<dynamic>
```

Импорты и экспорты в JavaScript – относительно непростая тема, поэтому иногда бывает сложно найти правильную комбинацию аннотаций, чтобы компилятор Котлина импортировал все правильно. Последние две строчки в нашем случае – это эквивалент `require("react-youtube-lite").default` в JS. Они говорят компилятору: "мы уверены, что в рантайме тут получится компонент, соответствующий `RClass<dynamic>`".

#### Типизированные обертки для компонента
Однако, оставив все в таком виде, мы откажемся от большого количества возможностей Котлина. Объявление `dynamic` типа говорит компилятору, что значение этого типа может быть любым. Компилятор не будет проверять такие объекты, а значит есть риск, что что-то сломается во время исполнения (например, в проде).

К счастью, мы уже видели, как в Котлине объявляются реактовские аттрибуты (как `external` интерфейс), а их имена мы можем найти опять же в README библиотеки. Так что на самом деле написание типобезопасных деклараций – довольно простая задача. Мы можем объявить только те свойства, которые будем использовать – в первую очередь нам будет полезно задавать ссылку на видео. Поменяем декларацию видеоплеера вот так:
```kotlin
@file:JsModule("react-youtube-lite")
@file:JsNonModule

import react.*

@JsName("ReactYouTubeLite")
external val reactPlayer: RClass<ReactYouTubeProps>

external interface ReactYouTubeProps : RProps {
    var url: String
}
```

Самое время заменить скучный серый прямоугольник внутри компонента `VideoPlayer` на только что задекларированный настоящий плеер! Удалим тег `img` и заменим его на следующее:
```kotlin
reactPlayer {
    attrs.url = props.video.videoUrl
}
```

### Добавляем кнопки шера
Получать удовольствие от докладов с KotlinConf лучше вместе (как и для многих других занятий). Кнопки шера – общепризнанный способ поделиться с друзьями и коллегами качественным контентом. Такие кнопки могут поддерживать например мессенджеры и электронную почту. Для кнопок есть уже существующие Реакт компоненты, например, из пакета [react-share](https://github.com/nygardk/react-share/blob/master/README.md). Этот пакет тоже уже объявлен в конфигурации Gradle:
```kotlin
dependencies {
    // ...
    // Share Buttons (шаг 7)
    implementation(npm("react-share", "~4.2.1"))
    // ...
}
```

Опять напишем декларации. Если посмотрим на [примеры](https://github.com/nygardk/react-share/blob/master/demo/Demo.tsx) с ГитХаба, увидим, что кнопки состоят из двух компонентов: например, `EmailShareButton` и `EmailIcon`. И почти все из них имеют одинаковые аттрибуты. Файл с декларациями получается примерно следующий; назовем его `ReactShare.kt`:
```kotlin
@file:JsModule("react-share")
@file:JsNonModule

import react.RClass
import react.RProps

@JsName("EmailIcon")
external val emailIcon: RClass<IconProps>

@JsName("EmailShareButton")
external val emailShareButton: RClass<ShareButtonProps>

@JsName("TelegramIcon")
external val telegramIcon: RClass<IconProps>

@JsName("TelegramShareButton")
external val telegramShareButton: RClass<ShareButtonProps>

external interface ShareButtonProps : RProps {
    var url: String
}

external interface IconProps : RProps {
    var size: Int
    var round: Boolean
}
```

Давайте добавим две кнопки над компонентом видеоплеера. Напишем следующий код перед вызовом `reactPlayer` (обернем в `styledDiv`, чтобы сделать расположение компонентов подходящим):
```kotlin
styledDiv {
    css {
        display = Display.flex
        marginBottom = 10.px
    }
    emailShareButton {
        attrs.url = props.video.videoUrl
        emailIcon {
            attrs.size = 32
            attrs.round = true
        }
    }
    telegramShareButton {
        attrs.url = props.video.videoUrl
        telegramIcon {
            attrs.size = 32
            attrs.round = true
        }
    }
}
```

Теперь можно проверить, что кнопки действительно работают. Если кликнуть по ним, должно открыться окно. Если же ничего не происходит, возможно, у Вас включен скрывающий такие кнопки блокировщик рекламы.
![pair](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729192417600.png)

Если хотите, можете написать декларации для других кнопок в этой библиотеке и тоже добавить их на экран.

> Состояние проекта после выполнения этого шага доступно в ветке `step-06-packages-from-npm` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-06-packages-from-npm).
