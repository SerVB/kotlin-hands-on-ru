# Практика по Котлину: Создание веб приложений на React и Kotlin/JS
*От переводчика*.

Привет! Про **Kotlin** есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ (**JVM**, **JS**, **Native**), а также умеет работать с библиотеками для этих платформ, написанных на других языках. Такая поддержка "мультиплатформенности" позволяет не только писать всевозможные проекты на одном языке в единой форме, но и переиспользовать код при написании одного проекта под разные платформы.

В этой статье я перевожу [официальный туториал Kotlin Hands-On](https://play.kotlinlang.org/hands-on/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS) о создании веб сайтов на Котлине. Мы рассмотрим многие аспекты программирования на Kotlin/JS и поймем, как работать не только с чистым DOM. В основном будем говорить о [ReactJS](https://reactjs.org/), но коснемся системы сборки **Gradle**, использования зависимостей из **NPM**, обращения к **REST API**, деплоя на **Heroku**, и в итоге сделаем приложение-видеоплеер.

<cut/>

Предлагать правки в эту статью можно [на ГитХабе](https://github.com/SerVB/kotlin-hands-on-ru). Текущий перевод построен на версии оригинального туториала, актуальной на 04.10.2020.

## Содержание
1. [Введение](#step1).
1. [Настройка](#step2).
1. [Первая страница на Реакте – статичная](#step3).

## <a name="step1">Шаг 1. Введение</a>
На этой практике мы рассмотрим, как использовать Kotlin/JS вместе с популярным фреймворком [React](https://reactjs.org/) для создания красивых и поддерживаемых браузерных приложений. React позволяет создавать веб приложения современно и структурированно, фокусируясь на переиспользовании компонентов и на особом способе управления состоянием приложения. Он имеет большую экосистему материалов и компонентов, созданную сообществом.

Использование Котлина для написания приложений на React позволяет опираться на наши знания о парадигмах, синтаксисе и инструментах этого языка при создании фронт-энд приложений для современных браузеров. А еще использовать котлиновские библиотеки одновременно с возможностями платформы и экосистемы JavaScript.

На этой практике мы научимся создавать приложение на Kotlin/JS и React, используя Gradle плагин `org.jetbrains.kotlin.js`. Мы решим задачи, обычно возникающие при создании типичного простого React приложения.

Мы узнаем, как *предметно-ориентированные языки* (*DSL*) помогают выражать идеи кратким и единообразным способом без жертв читаемости, давая возможность написать полноценное приложение полностью на Котлине. Также мы покажем, как использовать уже сделанные сообществом компоненты и библиотеки, и как опубликовать получившееся приложение.

Предполагается, что у Вас уже есть базовое понимание Котлина, и *совсем поверхностное* знание HTML и CSS. Базовое знание идей React будет полезным для понимания примеров кода, но не обязательно.

### Что именно мы создадим
Ежегодное событие [KotlinConf](https://kotlinconf.com/) стоит посетить, если Вы хотите узнать больше о Котлине и пообщаться с сообществом. KotlinConf 2018 предлагал огромное количество информации в виде мастер-классов и лекций и был посещен 1300 участниками. Доклады публично доступны на YouTube, и поклонникам Котлина было бы полезно **видеть список** докладов, **смотреть** их на единой странице и **помечать** их как *просмотренные* – идеально для погружения в Котлин "запоем". На этой практике мы как раз создадим такое приложение – *KotlinConf Explorer*.

![Результат](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729201914738.png)

Исходный код финального приложения, как и промежуточные результаты, можно найти [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle) на GitHub. Результат каждого шага доступен в соответствующей ветке, ссылки на которые мы дополнительно дублируем в конце каждого параграфа.

Начнем с настройки среды разработки и установки инструментов, которые помогут нам в работе.

## <a name="step2">Шаг 2. Настройка</a>
### Пререквизиты
Чтобы начать, давайте убедимся, что у Вас установлена актуальная среда разработки. Вот все, что нам нужно сейчас:
* IntelliJ IDEA (версии `2020.1` или новее) с плагином Котлин (`1.4.0` или новее) – скачать можно [по ссылке](https://www.jetbrains.com/idea/download/).

### Настраиваем проект
Мы будем собирать наш проект с помощью Gradle плагина `org.jetbrains.kotlin.js`. Он берет на себя работу с разными штуками из экосистемы JavaScript – под капотом он содержит *yarn* и *webpack*. Если нужно будет что-то настроить, это можно сделать через Gradle – настроенный совсем немного, плагин решит за нас все задачи, которые мы встретим на этой практике.

Простейший способ создать проект – с помощью визарда в IDE. Это можно сделать на начальном экране или из меню **File | New | Project...**. Нужно выбрать категорию **Gradle**, включить **Kotlin DSL build script** и отметить только **Kotlin/JS for browser** в качестве фреймворка:
![Выбор фреймворка](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/new_gradle_project.png)

После нажатия на кнопку **Next**, надо придумать название проекта. Я назвал проект `confexplorer`, потому что это то, что мы создаем, но Вы можете придумать и более творческое название:
![Название проекта](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/confexplorer.png)

Нажав на **Finish**, нам придется подождать несколько секунд, пока Gradle не настроит пустой проект, поддерживающий в качестве цели компиляции Котлина *JavaScript*. Когда импортирование проекта завершится, займемся добавлением зависимостей, которые мы будем использовать в ходе практики.

#### Зависимости и задачи Gradle
На практике мы будем использовать React, некоторые другие внешние зависимости, а еще котлиновские библиотеки. Чтобы не тратить время на импортирование изменений Gradle скриптов на каждом шаге, добавим все зависимости прямо сейчас.

Для начала давайте убедимся, что внутри файла `build.gradle.kts` есть блок `repositories`, который выглядит следующим образом:
```kotlin
repositories {
    maven("https://kotlin.bintray.com/kotlin-js-wrappers/")
    mavenCentral()
    jcenter()
}
```

Таким образом объявляются источники зависимостей. Теперь объявим сами зависимости с помощью блока `dependencies`, для удобства для зависимостей в комментариях подписаны шаги, где мы начнем их использовать:
```kotlin
dependencies {
    implementation(kotlin("stdlib-js"))

    // React, React DOM + Wrappers (шаг 3)
    implementation("org.jetbrains:kotlin-react:16.13.1-pre.110-kotlin-1.4.0")
    implementation("org.jetbrains:kotlin-react-dom:16.13.1-pre.110-kotlin-1.4.0")
    implementation(npm("react", "16.13.1"))
    implementation(npm("react-dom", "16.13.1"))

    // Kotlin Styled (шаг 3)
    implementation("org.jetbrains:kotlin-styled:1.0.0-pre.110-kotlin-1.4.0")
    implementation(npm("styled-components", "~5.1.1"))
    implementation(npm("inline-style-prefixer", "~6.0.0"))

    // Video Player (шаг 7)
    implementation(npm("react-player", "~2.6.0"))

    // Share Buttons (шаг 7)
    implementation(npm("react-share", "~4.2.1"))

    // Coroutines (шаг 8)
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9")
}
```

После редактирования файла, IDEA автоматически предложит импортировать изменения Gradle скриптов. Импорт также можно инициировать в любой момент, нажав на кнопку **🔁 Reimport All Gradle Projects** в тул-окне Gradle (сбоку справа).

#### HTML страница
Так как мы не можем вызывать JavaScript сам по себе, мы должны написать связанную с нашим JS файлом HTML страницу, и именно ее открывать в браузере. Давайте создадим в проекте файл `src/main/resources/index.html` (**File | New | File**) со следующим содержимым:
```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hello, Kotlin/JS!</title>
</head>
<body>
    <div id="root"></div>
    <script src="confexplorer.js"></script>
</body>
</html>
```

Название упоминаемого JS файла зависит от названия проекта, у Вас оно может быть другим. Например, если Вы назвали проект `followingAlong`, имя скрипта будет `followingAlong.js`. Благодаря Gradle плагину, весь наш код и зависимости будут объединены ("забандлены") в единый JavaScript артефакт, носящий с проектом одно имя.

Перед написанием "Hello, World" с настоящей разметкой, начнем с простейшего визуального примера – страницы, залитой сплошным цветом. Этот пример поможет понять, то что наш код действительно доходит до браузера и выполняется без ошибок. Для этого создадим файл `src/main/kotlin/Main.kt`:
```kotlin
import kotlinx.browser.document

fun main() {
    document.bgColor = "red"
}
```

Теперь нам нужно скомпилировать и запустить наш код.

### Запуск сервера для разработки
`kotlin.js` Gradle плагин из коробки поддерживает **webpack-dev-server**, что позволяет нам хостить приложение прямо с помощью IDE и не настраивать подобный веб сервер отдельно.

Мы можем стартовать сервер, вызвав задачу `run` или `browserDevelopmentRun` из тул-окна Gradle:
![Задача для запуска сервера](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/browserDevelopmentRun.png)

Если хочется запускать не из IDE, а из терминала, то можно выполнить `./gradlew run` (*в Windows* Gradle команды выглядят немного по-другому: `.\gradlew.bat run`).

Наш проект скомпилируется и забандлится, и через несколько секунд должно открыться окно браузера с пустой красной страницей, означающей, что наш код заработал успешно:
![Красная страница](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/redPage.png)

#### Включение горячей перезагрузки (hot reload) a.k.a. непрерывного режима
Вместо того чтобы вручную вызывать компиляцию проекта и обновление страницы в браузере для тестирования изменений в коде, мы можем использовать *режим непрерывной компиляции* – Kotlin/JS поддерживает ее. Для этого нам потребуется немного модифицировать вызов `run` задачи Gradle.

Необходимо также убедиться, что запущенный ранее веб сервер остановлен (нажмите в IDE на красный квадрат – **Stop**, а в терминале – `Ctrl+C`).

Если Вы запускаете задачу с помощью IDEA, нужно добавить флаг в конфигурацию запуска. Эту конфигурацию IDEA создала, когда мы впервые запустили Gradle задачу, а теперь нам нужно ее отредактировать:
![Открытие редактирования](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/editConfigurations.png)

В открывшемся окне **Run/Debug Configurations** надо добавить флаг `--continuous` в аргументы конфигурации запуска:
![Добавление аргумента](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/continuous.png)

После применения изменений, мы можем использовать зеленую кнопку **Run** (▶) для запуска сервера.

Если Вы запускаете из терминала, это можно сделать примерно так: `./gradlew run --continuous`.

Для тестирования только что активированной функции, предлагаем изменить цвет страницы, когда Gradle задача выполняется. Например, можно изменить на синий:
```kotlin
document.bgColor = "blue"
```

Если сохранить файл, через пару секунд проект должен автоматически перекомпилироваться, а страница браузера – перезагрузиться и окраситься в новый цвет.

Во время разработки можно оставлять сервер запущенным. Он будет следить за изменениями в коде и автоматически компилировать код и перезагружать страницу. Если хотите, можете поиграться с кодом на этой начальной стадии.

#### Примечание от переводчика насчет непрерывной компиляции
Если честно, я пробовал этот режим, и он мне показался неудобным. Во-первых, перезагрузка страницы иногда бывает нежелательна, особенно если там были какие-то несохраненные данные. Во-вторых, я не всегда понимаю, успели ли уже перекомпилироваться код и перезагрузиться страница. В-третьих, этот режим почему-то не всегда видит изменения, и доходит до того, что приходится перезапускать Gradle задачу, то есть сама суть режима нарушается – все еще приходится делать что-то руками.

В итоге, я уже года полтора, с момента начала моего использования Kotlin/JS, вручную запускаю компиляцию кода и перезагрузку страницы. Более того, я вообще не использую веб сервер при разработке: я просто открываю в браузере локальный HTML файл. Для компиляции я использую задачу `browserDevelopmentWebpack`, после этого построенные файлы становятся доступны в папке `build/distributions`. Оттуда я переношу в браузер файл `index.html`, и все работает довольно безотказно и предельно логично.

### На старт, внимание...
Мы настроили пустой Kotlin/JS проект, который может развиться во все что угодно. Время начинать верстать!

> Состояние проекта после выполнения этого шага доступно в ветке `master` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/master).

## <a name="step3">Шаг 3. Первая страница на Реакте – статичная</a>
В мире программирования принято начинать обучение с *Hello, World*. Так давайте изменим нашу одноцветную страницу в соответствии с традициями.

Поменяйте код в файле `src/main/kotlin/Main.kt` на примерно следующий:
```kotlin
import react.dom.*
import kotlinx.browser.document

fun main() {
    render(document.getElementById("root")) {
        h1 {
            +"Hello, React+Kotlin/JS!"
        }
    }
}
```

После сборки изменившегося проекта в браузере можно увидеть магию:
![hello-world](https://github.com/kotlin-hands-on/hands-on/raw/6f3afd1/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729142055566.png)

Ура, Вы только что написали свой первый вебсайт на чистом Котлине с Реактом! Давайте попробуем понять, как работает этот код. Функция `render` говорит библиотеке [kotlin-react-dom](https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-dom) отрендерить наш *компонент* (поговорим о компонентах чуть позже) внутрь элемента на странице. Если помните, в `src/main/resources/index.html` есть элемент с ID `root`, как раз туда мы и рендерим. Содержимое рендеринга сейчас довольно простое – единственный заголовок первого уровня. Для объявления содержимого, то есть HTML элементов, используется типобезопасный DSL.

### Типобезопасный HTML
Библиотека [kotlin-react](https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-react/README.md) использует котлиновскую возможность написания DSL, таким образом заменяя синтаксис разметки HTML на нечто более легкочитаемое. Возможно, такой DSL Вам покажется и легче в написании.

Код на Котлине дает нам все преимущества статически типизированного языка, от *проверки типов* до *автодополнения*. Скорее всего, из-за этого Вы проведете *меньше времени в отладке*, охотясь за опечатками в именах аттрибутов, и у Вас появится *больше времени на создание* отточенного приложения!

**О знаке `+`**:

Единственная довольно неочевидная на первый взгляд вещь в котлиновском листинге выше – знак `+` перед строковым литералом. Поясним! `h1` – это функция, принимающая лямбду как параметр. Когда мы пишем `+`, мы на самом деле вызываем [перегруженный оператор](https://kotlinlang.org/docs/reference/operator-overloading.html) `unaryPlus`, которая добавляет строку в окружающий HTML элемент.

Проще говоря, операцию `+` можно понимать как инструкцию "добавь мою строчку текста внутрь этого элемента".

#### Переписываем классический HTML
Когда у нас есть мысли о том, как будет выглядеть наш сайт, мы можем сразу перевести наш (мысленный) набросок в котлиновское объявление HTML. Если Вы уже привыкли писать обычный HTML, у Вас не должно возникнуть проблем и с котлиновским. Сейчас мы хотим создать разметку, которую можно записать примерно так на чистом HTML:
```html
<h1>KotlinConf Explorer</h1>
<div>
    <h3>Videos to watch</h3>
    <p>John Doe: Building and breaking things</p>
    <p>Jane Smith: The development process</p>
    <p>Matt Miller: The Web 7.0</p>

    <h3>Videos watched</h3>
    <p>Tom Jerry: Mouseless development</p>
</div>
<div>
    <h3>John Doe: Building and breaking things</h3>
    <img src="https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder">
</div>
```

Давайте переведем этот код в Kotlin DSL. Конверсия довольно прямолинейна. Если хотите поупражняться, можете попробовать переписать самостоятельно, **не подглядывая** в листинг ниже:
```kotlin
h1 {
    +"KotlinConf Explorer"
}
div {
    h3 {
        +"Videos to watch"
    }
    p {
        +"John Doe: Building and breaking things"
    }
    p {
        +"Jane Smith: The development process"
    }
    p {
        +"Matt Miller: The Web 7.0"
    }

    h3 {
        +"Videos watched"
    }
    p {
        +"Tom Jerry: Mouseless development"
    }
}
div {
    h3 {
        +"John Doe: Building and breaking things"
    }
    img {
       attrs {
           src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
       }
    }
}
```

Перепишите или скопируйте этот листинг внутрь вызова `render`. Если IntelliJ IDEA ругается на отсутствующие импорты, просто вызовите соответствующие быстрые исправления (quick-fixes) с помощью `Alt+Enter`. Когда обновленный файл будет скомпилирован и страница в браузере перезагружена, Вас будет приветствовать следующий экран:
![kotlinconf-placeholder](https://github.com/kotlin-hands-on/hands-on/raw/88eabcf/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS/assets/image-20190729143514676.png)

### Использование котлиновских языковых конструкций в разметке
Написание HTML на DSL на самом деле имеет намного больше преимуществ, по сравнению с чистым HTML. Основное отличие – это то что мы можем жонглировать контентом страницы, используя **уже знакомые нам конструкции языка**. Условные переходы, циклы, коллекции, подстановка внутри строк – все это будет работать в HTML DSL так же, как и обычно в Котлине.

Давайте теперь вместо захардкоживания списка видео объявим переменную-список и будем ее использовать в разметке. Создадим простой класс, чтобы объединить свойства видео (класс можно создать либо в `Main.kt`, либо в другом файле – как хотите):
```kotlin
data class Video(val id: Int, val title: String, val speaker: String, val videoUrl: String)
```

Потом объявим два списка: для непросмотренных и просмотренных видео. Пока что можно сделать это в файле `Main.kt` на верхнем уровне:
```kotlin
val unwatchedVideos = listOf(
        Video(1, "Building and breaking things", "John Doe", "https://youtu.be/PsaFVLr8t4E"),
        Video(2, "The development process", "Jane Smith", "https://youtu.be/PsaFVLr8t4E"),
        Video(3, "The Web 7.0", "Matt Miller", "https://youtu.be/PsaFVLr8t4E")
)

val watchedVideos = listOf(
        Video(4, "Mouseless development", "Tom Jerry", "https://youtu.be/PsaFVLr8t4E")
)
```

Чтобы использовать эти значения в HTML, нам не нужно знать ничего, кроме базового синтаксиса Котлина! Мы можем написать код для прохода по коллекции и добавлять HTML элемент для каждого элемента коллекции. То есть вместо трех тегов `p` для непросмотренных видео, мы можем написать примерно такое:
```kotlin
for(video in unwatchedVideos) {
    p {
        +"${video.speaker}: ${video.title}"
    }
}
```

Аналогично можно изменить разметку чуть ниже для использования списка `watchedVideos`. После перекомпиляции проекта и обновления страницы мы убедимся, что страница эквивалентна предыдущему варианту. Если хотите удостовериться, что циклы на самом деле работают, попробуйте поэкспериментировать и, например, добавить новые элементы в списки.

### Типобезопасный CSS
Можно сказать, мы уже продвинулись в проекте, но не время делать паузу: к сожалению, наше приложение до сих пор выглядит *несколько безвкусно* и *не сильно привлекательно*. Для исправления ситуации мы могли бы подключить какой-нибудь `.css` файл в наш файл `index.html`, но давайте лучше воспользуемся случаем, чтобы поиграться с Kotlin DSL опять – на этот раз с CSS.

Библиотека [kotlin-styled](https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-styled) предоставляет чудесные типобезопасные обертки для [styled-components](https://www.styled-components.com/) и позволяет нам быстро и безопасно объявлять стили как [глобально](https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-styled/README.md#global-styles), так индивидуально для конкретных компонентов. Эти обертки очень похожи на концепт [CSS-in-JS](https://reactjs.org/docs/faq-styling.html#what-is-css-in-js). Описывая стили *на Котлине*, мы опять же получаем возможность использовать краткие, понятные и единообразные языковые конструкции.

Нам не нужно делать дополнительных шагов для использования этого CSS DSL, так как мы уже добавили все зависимости в конфигурацию Gradle. Вот соответствующий блок:
```kotlin
dependencies {
    //...
    //Kotlin Styled (шаг 3)
    implementation("org.jetbrains:kotlin-styled:1.0.0-pre.110-kotlin-1.4.0")
    implementation(npm("styled-components", "~5.1.1"))
    implementation(npm("inline-style-prefixer", "~6.0.0"))
    //...
}
```

Теперь вместо блоков вроде `div` или `h3` мы можем использовать их аналоги с префиксом `styled`, например, `styledDiv` или `styledH3`. Внутри их тел мы можем настраивать стили с помощью блока `css`. Например, для сдвига видеоплеера в правый верхний угол страницы, мы можем изменить наш код примерно так:
```kotlin
styledDiv {
    css {
        position = Position.absolute
        top = 10.px
        right = 10.px
    }
    h3 {
        +"John Doe: Building and breaking things"
    }
    img {
        attrs {
            src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
        }
    }
}
```

Скорее всего, IDEA начнет жаловаться на непонятные ссылки. Мы можем избавиться от этих ошибок, добавив импорты сверху в файле:
```kotlin
import kotlinx.css.*
import styled.*
```

Или можно воспользоваться быстрыми исправлениями с помощью `Alt+Enter` для добавления импортов автоматически.

Мы привели довольно минималистичный пример. Не стесняйтесь поэкспериментировать – поменять стиль приложения, как душе угодно. Можете даже поиграться с CCS Grids, чтобы сделать интерфейс отзывчивым (но эта тема уже слишком сложна для этого туториала). Попробуйте сделать шрифт (свойство `fontFamily`) заголовка без засечек (значение `sans-serif`), или, например, сделать красивые цвета (свойство `color`).

> Состояние проекта после выполнения этого шага доступно в ветке `step-02-first-static-page` [в репозитории](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-02-first-static-page).
